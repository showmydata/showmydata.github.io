---
layout: post
title: "2022春-人工智能-第9讲"
categories: 
  - Courses
tags:
  - 课程学习
  - 人工智能
last_modified_at: 2022-03-22T21:00:52+08:00
---

### 状态空间盲目搜索

#### 一般图搜索过程

- Open表：未扩展的节点
- Close表：已扩展的节点
- $S_0$：表示问题的初始状态
- $S_g$：表示问题的目标状态

- 步骤

  - 把$S_0$放入Open表，图G仅包含$S_0$，Close表为空

  - 检查Open表是否为空表，若为空则问题无解

  - 把Open表的第一个节点放入Close表，记该节点为n

  - 考察n是否为目标节点，若是则得到问题的解

  - 扩展结点n，生成一组子节点。把这些子节点中不是其父节点的那部分子节点计入集合M，并把这些子节点作为节点n的子节点加入G中

  - 对于M中子节点的不同情况

    - 没有在G中出现过：设置一个指向其父节点（即节点n）的指针，并放入Open表中

    - 已经在G中出现过，没有被扩展过：确定是否修改它指向父节点的指针

    - 已经在G中出现过，被扩展过：确定是否需要修改其后继节点指向父节点的指针

    - > 后两种情况，一般都是依据从原始节点到该节点路径的代价，来进行确定的

  - 按某种策略对Open表中的节点进行排序

  - 转第2步

#### 状态空间启发式搜索

- 启发信息

  - 有效确定扩展节点
  - 有效决定后继节点生成
  - 有效决定扩展节点时哪些结点被删除

- 估价函数

  - $f(n)=g(n)+h(n)$
  - $g(n)$是实际代价；$h(n)$是估计代价，体现启发式信息，也称为启发函数
  - $h(n)$可以为曼哈顿距离或者欧几里得距离（在迷宫路径搜索中）

- A*算法相关约束

  - 定义
    - 设$f^*(n)$是从$S_0$经过结点n到达$S_g$的最小代价，估价函数$f(n)$是对$f^*(n)$的估计值
    - 记$f^*(n)=g^*(n)+h^*(n)$
    - 其中，$g^*(n)$是从$S_0$到节点n的最小代价，$h^*(n)$是从节点n到$S_g$的最小代价
  - 约束
    - $g(n)$是对最小代价$g^*(n)$的估计，且大于0
    - $h(n)$是最小代价$h^*(n)$的下界，即对任意节点n均有$h(n)\le h^*(n)$

  - 可纳性
    - 定义：当从初始节点到目标节点有路径存在时，能在有限步骤内找到最佳路径，并在此路径上结束
    - 证明：
      - 对有限图，一定能成功结束
        - 必然结束：有限图，若有解则必然成功结束；若无解则会由于Open表变空而结束
        - 必然成功结束：至少存在一条有初始节点到目标节点的路径，Open表变空之前目标节点必然出现在Open表中
      - 对无限图，一定能成功结束
        - 有路径存在，若不终止，必将有任意大的$f(n)$值
        - 算法终止前，Open表中总存在节点n'，它是最佳路径上的一个节点，且$f(n^{'})\le f^*(S_0)$
        - 由前面两条结合，用反证法，若A*不结束，则有任意大的f值，与第二条不符，故算法一定结束
      - 必能结束在最佳路径上
        - 由前面两条，必然结束在某个目标节点上
        - 再证只能终止在最佳路径上（反证法）
          - 若终止在节点t处，不是最佳路径，则有$f(t)=g(t)>f^*(S_0)$
          - 由之前引理，Open表中必有一个最佳路径上的节点n'，且$f(n^{'})\le f^{*}(S_0)\le f(t)$
          - 此时必选择n'扩展，而非t，矛盾
    - 推论
      - Astar算法中，对任何被扩展的节点n，都有$f(n)\le f^*(S_0)$
  - 最优性
    - 定义：$h(n)$的值越大，有更多的启发性信息，扩展的节点数更少
  - $h(n)$的单调限制
    - 避免扩展结点时检查是否调整指向父节点的指针、后继结点的父指针等
    - 定义：
      - $h(S_g)=0$
      - 对任意结点$n_i$和其任一子节点$n_j$，都有$0\le h(n_i)-h(n_j)\le c(n_i,n_j)$，$c(n_i,n_j)$是两节点间的边代价
    - 若h满足单调条件，则Astar算法扩展节点n时就得到了最佳路径，即$g(n)=g^*(n)$
    - 若h满足单调限制，则Astar算法扩展的节点序列的f值是非递减的，$f(n_i)\le f(n_{i+1})$
  - 

#### 几种搜索算法的归纳总结

- 广度优先搜索BFS
  - 扩展节点n后，将其子节点放入Open表的尾部
  - 队列
- 深度优先搜索DFS
  - 扩展节点n后，将其子节点放入Open表的首部
  - 栈
  - 迭代加深的深度优先搜索-限制DFS搜索深度（有界深度的DFS）

- 代价一致搜索UCS

  - 扩展节点n后，将其子节点放入Open表，计算各节点代价，对Open表内的节点按代价从小到大排序
  - 优先队列

- A算法

  - 扩展节点n后，将其子节点放入Open表，计算各节点估价值，对Open表内的节点按估价值从小到大排序

- A*算法

  - 对A算法的估价函数$f(n)=g(n)+h(n)$加上某些限制
  - 

  
